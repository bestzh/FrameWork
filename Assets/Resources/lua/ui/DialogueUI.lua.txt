---@diagnostic disable: undefined-global
---@diagnostic disable: unused-local
-- 对话UI - Lua实现
-- 支持热更新，所有UI逻辑都在Lua中

local CoroutineHelper = require("coroutine_helper")
local TableHelper = require("rpg.table.table_helper")
local EventHelper = require("event_helper")

local DialogueUI = {}

-- UI组件引用
local currentUI = nil
local npcNameText = nil
local dialogueText = nil
local npcAvatarImage = nil
local closeButton = nil
local optionsContainer = nil  -- 选项容器（VerticalLayoutGroup或GridLayoutGroup）
local OptionButtonTemplate = nil  -- 选项按钮模板

-- 设置
local typingSpeed = 0.05  -- 打字机效果速度
local useTypingEffect = true  -- 是否使用打字机效果

-- 状态
local currentDialogue = ""
local typingCoroutine = nil
local onDialogueClosed = nil
local onOptionSelected = nil  -- 选项选择回调
local isTyping = false
local currentOptions = {}  -- 当前对话选项列表
local optionButtons = {}  -- 选项按钮列表
local optionButtonPrefab = nil  -- 选项按钮预制体（可选，如果使用动态创建）

-- 辅助函数：检查点击是否在UI上
local function IsPointerOverUI()
    -- 检查EventSystem是否存在
    local eventSystem = CS.UnityEngine.EventSystems.EventSystem.current
    if eventSystem == nil then
        return false
    end
    
    -- 检查鼠标/触摸是否在UI上
    local isOverUI = eventSystem:IsPointerOverGameObject()
    return isOverUI
end

-- 辅助函数：打印UI层级结构（用于调试）
local function PrintUITree(transform, indent)
    indent = indent or ""
    if not transform then
        return
    end
    
    local name = transform.name
    print(indent .. name)
    
    local childCount = transform.childCount
    for i = 0, childCount - 1 do
        local child = transform:GetChild(i)
        if child then
            PrintUITree(child, indent .. "  ")
        end
    end
end

-- 初始化UI组件引用
local function InitializeComponents(ui)

    local npcNameObj = ui.transform:Find("NPCNameText")
    if npcNameObj then
        npcNameText = npcNameObj:GetComponent("TextMeshProUGUI")
    end

    local dialogueObj = ui.transform:Find("DialogueText")
    if dialogueObj then
        dialogueText = dialogueObj:GetComponent("TextMeshProUGUI")
    end

    local avatarObj = ui.transform:Find("NPCAvatar")
    if avatarObj then
        npcAvatarImage = avatarObj:GetComponent("Image")
    end

    local closeBtnObj = ui.transform:Find("CloseButton")
    if closeBtnObj then
        closeButton = closeBtnObj:GetComponent("Button")
    end

    -- 查找选项容器（支持多种命名方式）
    local optionsContainerObj = ui.transform:Find("OptionsContainer")
    if optionsContainerObj then
        optionsContainer = optionsContainerObj.gameObject
    end
    
    -- 查找选项按钮模板（在DialogueUI下，与OptionsContainer平级）
    local optionButtonTemplateObj = ui.transform:Find("OptionButton")
    if optionButtonTemplateObj then
        OptionButtonTemplate = optionButtonTemplateObj.gameObject
        -- 默认隐藏模板（作为模板使用）
        OptionButtonTemplate:SetActive(false)
        print("[DialogueUI] 找到选项按钮模板: " .. OptionButtonTemplate.name)
    else
        print("[DialogueUI] 警告: 未找到选项按钮模板 OptionButton")
    end

end

-- UTF-8 安全的字符串截取函数（按字符而不是按字节）
local function utf8Sub(str, start, finish)
    -- 如果 Lua 版本支持 utf8 库，使用它
    if utf8 and utf8.codes then
        local chars = {}
        for _, char in utf8.codes(str) do
            table.insert(chars, utf8.char(char))
        end
        local subChars = {}
        local endIndex = finish or #chars
        for i = start, math.min(endIndex, #chars) do
            if chars[i] then
                table.insert(subChars, chars[i])
            end
        end
        return table.concat(subChars)
    else
        -- 降级方案：逐字符处理（更安全但较慢）
        -- 使用 pattern 匹配来找到每个 UTF-8 字符
        local chars = {}
        for char in string.gmatch(str, "([%z\1-\127\194-\244][\128-\191]*)") do
            table.insert(chars, char)
        end
        local subChars = {}
        local endIndex = finish or #chars
        for i = start, math.min(endIndex, #chars) do
            if chars[i] then
                table.insert(subChars, chars[i])
            end
        end
        return table.concat(subChars)
    end
end

-- 获取 UTF-8 字符串的字符数量
local function utf8Len(str)
    if utf8 and utf8.codes then
        local count = 0
        for _ in utf8.codes(str) do
            count = count + 1
        end
        return count
    else
        -- 使用 pattern 匹配来统计字符数
        local count = 0
        for _ in string.gmatch(str, "([%z\1-\127\194-\244][\128-\191]*)") do
            count = count + 1
        end
        return count
    end
end

-- 打字机效果（使用DelayCall实现，避免协程配置问题）
local function TypeText(text)
    if not dialogueText then
        return
    end
    
    -- 停止之前的打字机效果（如果存在）
    if typingCoroutine then
        typingCoroutine.isActive = false
        typingCoroutine = nil
    end
    
    isTyping = true
    dialogueText.text = ""
    
    -- 获取字符数量（而不是字节数）
    local charCount = utf8Len(text)
    
    -- 创建打字机状态对象
    local typingState = {
        index = 1,
        textLength = charCount,
        text = text,
        isActive = true
    }
    typingCoroutine = typingState
    
    -- 使用DelayCall递归实现打字机效果
    local function ShowNextChar()
        -- 检查是否被停止
        if not typingState.isActive or typingCoroutine ~= typingState then
            isTyping = false
            return
        end
        
        if typingState.index > typingState.textLength then
            -- 打字完成
            isTyping = false
            typingCoroutine = nil
            -- 打字完成后显示选项（如果有）
            local optionsCount = TableHelper.GetCount(currentOptions)
            print("[DialogueUI] 打字机效果完成，当前选项数量: " .. optionsCount)
            if optionsCount > 0 then
                print("[DialogueUI] 准备显示选项...")
                DialogueUI.ShowOptions()
            else
                print("[DialogueUI] 警告: 打字完成后没有选项可显示")
            end
            return
        end
        
        -- 显示当前字符（使用 UTF-8 安全的方式）
        if dialogueText then
            dialogueText.text = utf8Sub(typingState.text, 1, typingState.index)
        end
        typingState.index = typingState.index + 1
        
        -- 延迟显示下一个字符
        if typingState.isActive and typingCoroutine == typingState then
            CoroutineHelper.DelayCall(ShowNextChar, typingSpeed)
        end
    end
    
    -- 开始打字
    ShowNextChar()
end

-- 跳过打字机效果
function DialogueUI.SkipTyping()
    if isTyping and dialogueText then
        -- 停止打字机效果
        if typingCoroutine then
            typingCoroutine.isActive = false
            typingCoroutine = nil
        end
        
        -- 直接显示全部文本
        dialogueText.text = currentDialogue
        isTyping = false
        
        -- 打字完成后显示选项
        if TableHelper.GetCount(currentOptions) > 0 then
            DialogueUI.ShowOptions()
        end
    end
end

-- 清除所有选项按钮（只清除UI，不清空选项数据）
local function ClearOptions()
    if optionsContainer then
        local childCount = optionsContainer.transform.childCount
        for i = childCount - 1, 0, -1 do
            local child = optionsContainer.transform:GetChild(i)
            if child then
                CS.UnityEngine.Object.Destroy(child.gameObject)
            end
        end
    end
    optionButtons = {}
    -- 注意：不清空 currentOptions，因为选项数据需要保留用于显示
end

-- 清除选项数据（在显示新对话时调用）
local function ClearOptionsData()
    currentOptions = {}
    optionButtons = {}
end

-- 显示对话选项
function DialogueUI.ShowOptions()
    print("[DialogueUI] ShowOptions被调用")
    
    if not optionsContainer then
        print("[DialogueUI] 错误: 选项容器不存在，无法显示选项")
        return
    end
    
    -- 清除之前的选项UI（不清除数据）
    ClearOptions()
    
    local optionsCount = TableHelper.GetCount(currentOptions)
    print("[DialogueUI] 当前选项数量: " .. optionsCount)
    
    if optionsCount == 0 then
        -- 没有选项，隐藏选项容器
        print("[DialogueUI] 没有选项，隐藏选项容器")
        if optionsContainer then
            optionsContainer:SetActive(false)
        end
        return
    end
    
    -- 显示选项容器
    if optionsContainer then
        optionsContainer:SetActive(true)
    end
    
    -- 确保currentOptions是Lua table
    if type(currentOptions) ~= "table" then
        currentOptions = TableHelper.ConvertToLuaTable(currentOptions)
    end
    
    print("[DialogueUI] 开始创建选项按钮，选项数量: " .. optionsCount)
    
    if not OptionButtonTemplate then
        print("[DialogueUI] 错误: 选项按钮模板不存在，无法创建选项按钮")
        return
    end
    
    if not optionsContainer then
        print("[DialogueUI] 错误: 选项容器不存在，无法创建选项按钮")
        return
    end
    
    for i, option in ipairs(currentOptions) do
        print("[DialogueUI] 创建选项 " .. i .. ": " .. tostring(option.text))
        
        -- 使用模板创建新的选项按钮
        local optionButtonObj = CS.UnityEngine.Object.Instantiate(OptionButtonTemplate)
        optionButtonObj.name = "OptionButton" .. i
        optionButtonObj.transform:SetParent(optionsContainer.transform, false)
        
        -- 获取按钮组件
        local button = optionButtonObj:GetComponent("Button")
        local textObj = optionButtonObj.transform:Find("Text")
        if not textObj then
            print("[DialogueUI] 错误: 选项按钮 " .. i .. " 中未找到Text子对象")
            CS.UnityEngine.Object.Destroy(optionButtonObj)
            return
        end
        
        local buttonText = textObj:GetComponent("TextMeshProUGUI")
        if not buttonText then
            print("[DialogueUI] 错误: 选项按钮 " .. i .. " 的Text对象没有TextMeshProUGUI组件")
            CS.UnityEngine.Object.Destroy(optionButtonObj)
            return
        end
        
        if not button then
            print("[DialogueUI] 错误: 选项按钮 " .. i .. " 没有Button组件")
            CS.UnityEngine.Object.Destroy(optionButtonObj)
            return
        end
        
        buttonText.text = option.text or option.optionText or ("选项" .. i)
        print("[DialogueUI] ✓ 选项按钮 " .. i .. " 文本已设置: " .. buttonText.text)
        
        -- 清除之前的点击事件（如果有）
        button.onClick:RemoveAllListeners()
        
        -- 绑定点击事件
        local optionIndex = i
        UIHelper.BindButtonWithSound(button, function()
            DialogueUI.OnOptionSelected(optionIndex)
        end)
        
        -- 激活按钮
        optionButtonObj:SetActive(true)
        table.insert(optionButtons, optionButtonObj)
    end
    
    print("[DialogueUI] 选项按钮创建完成，共创建 " .. #optionButtons .. " 个按钮")
    
    print("[DialogueUI] 选项按钮创建完成，共创建 " .. #optionButtons .. " 个按钮")
end

-- 选项被选择
function DialogueUI.OnOptionSelected(optionIndex)
    print("[DialogueUI] OnOptionSelected被调用，选项索引: " .. tostring(optionIndex))
    
    local optionsCount = TableHelper.GetCount(currentOptions)
    print("[DialogueUI] 当前选项数量: " .. tostring(optionsCount))
    
    if optionIndex < 1 or optionIndex > optionsCount then
        print("[DialogueUI] 错误: 选项索引超出范围: " .. tostring(optionIndex) .. " (范围: 1-" .. tostring(optionsCount) .. ")")
        return
    end 
    
    -- 确保currentOptions是Lua table
    if type(currentOptions) ~= "table" then
        currentOptions = TableHelper.ConvertToLuaTable(currentOptions)
    end
    
    local selectedOption = currentOptions[optionIndex]
    if not selectedOption then
        print("[DialogueUI] 错误: 无法获取选项 " .. tostring(optionIndex))
        return
    end
    
    print("[DialogueUI] 选中的选项: " .. tostring(selectedOption.text) .. " (action: " .. tostring(selectedOption.action) .. ")")
    
    -- 先清除选项UI（防止重复点击）
    ClearOptions()
    
    -- 调用选项选择回调
    if onOptionSelected then
        print("[DialogueUI] 调用选项选择回调...")
        onOptionSelected(selectedOption, optionIndex)
        print("[DialogueUI] 选项选择回调已执行")
    else
        print("[DialogueUI] 警告: 选项选择回调不存在 (onOptionSelected = nil)")
    end
    
    -- 注意：不清空选项数据（currentOptions），因为：
    -- 1. 如果是多段对话，下一个节点会通过ShowDialogue重新设置选项数据
    -- 2. 如果是单段对话，对话会关闭，选项数据会在CloseDialogue中清空
    -- 3. 如果立即清空，打字机效果完成时可能无法显示选项
end

-- 显示对话
-- npcName: NPC名称
-- dialogue: 对话内容
-- avatarPath: NPC头像路径（可选）
-- options: 对话选项列表（可选）格式: {{text="选项1", action="open_shop"}, {text="选项2", action="close"}}
-- optionCallback: 选项选择回调（可选）function(option, index)
-- closedCallback: 对话关闭回调（可选）
function DialogueUI.ShowDialogue(npcName, dialogue, avatarPath, options, optionCallback, closedCallback)
    if not currentUI then
        print("[DialogueUI] 错误: UI未初始化")
        return
    end
    
    print("[DialogueUI] ShowDialogue被调用 - NPC名称: " .. tostring(npcName) .. ", 对话: " .. tostring(dialogue))
    
    -- 清除之前的选项UI和数据（显示新对话）
    ClearOptions()
    ClearOptionsData()
    
    -- 设置NPC名称
    if npcNameText then
        -- 确保GameObject是激活的
        if npcNameText.gameObject then
            npcNameText.gameObject:SetActive(true)
        end
        npcNameText.text = npcName or ""
        print("[DialogueUI] ✓ NPC名称已设置: " .. tostring(npcNameText.text))
    else
        print("[DialogueUI] ✗ 错误: npcNameText组件为空，无法设置NPC名称")
        -- 尝试重新查找组件
        InitializeComponents(currentUI)
        if npcNameText then
            npcNameText.text = npcName or ""
            print("[DialogueUI] ✓ 重新查找后，NPC名称已设置: " .. tostring(npcNameText.text))
        end
    end
    
    -- 保存对话内容和回调（使用不同的参数名避免作用域冲突）
    currentDialogue = dialogue or ""
    onDialogueClosed = closedCallback
    onOptionSelected = optionCallback
    
    print("[DialogueUI] 回调已设置 - onOptionSelected: " .. tostring(onOptionSelected ~= nil) .. ", onDialogueClosed: " .. tostring(onDialogueClosed ~= nil))
    
    -- 将options转换为Lua table（支持C#数组/List）
    currentOptions = TableHelper.ConvertToLuaTable(options)
    
    -- 调试信息
    local optionsCount = TableHelper.GetCount(currentOptions)
    print("[DialogueUI] 选项数量: " .. optionsCount)
    if optionsCount > 0 then
        print("[DialogueUI] 选项列表:")
        for i, opt in ipairs(currentOptions) do
            print("  [" .. i .. "] " .. tostring(opt.text) .. " (action: " .. tostring(opt.action) .. ")")
        end
    end
    
    -- 设置头像
    if npcAvatarImage then
        if avatarPath and avatarPath ~= "" then
            local sprite = ResHelper.Load(avatarPath, "Sprite")
            if sprite then
                npcAvatarImage.sprite = sprite
                npcAvatarImage.gameObject:SetActive(true)
            else
                npcAvatarImage.gameObject:SetActive(false)
            end
        else
            npcAvatarImage.gameObject:SetActive(false)
        end
    end
    
    -- 显示对话文本
    if dialogueText then
        -- 确保GameObject是激活的
        if dialogueText.gameObject then
            dialogueText.gameObject:SetActive(true)
        end
        -- 停止之前的打字机效果（如果有）
        if typingCoroutine then
            typingCoroutine.isActive = false
            typingCoroutine = nil
        end
        isTyping = false
        
        -- 设置对话文本
        if useTypingEffect and currentDialogue ~= "" then
            -- 使用打字机效果
            print("[DialogueUI] 开始打字机效果，文本: " .. tostring(currentDialogue) .. ", 长度: " .. #currentDialogue)
            TypeText(currentDialogue)
            -- 打字完成后会显示选项（在TypeText完成时）
        else
            -- 直接显示全部文本
            dialogueText.text = currentDialogue
            print("[DialogueUI] ✓ 对话文本已直接设置: " .. tostring(dialogueText.text))
            isTyping = false
            -- 立即显示选项（如果有）
            if TableHelper.GetCount(currentOptions) > 0 then
                DialogueUI.ShowOptions()
            end
        end
    else
        print("[DialogueUI] ✗ 错误: dialogueText组件为空，无法显示对话文本")
        -- 尝试重新查找组件
        InitializeComponents(currentUI)
        if dialogueText then
            if dialogueText.gameObject then
                dialogueText.gameObject:SetActive(true)
            end
            dialogueText.text = currentDialogue
            print("[DialogueUI] ✓ 重新查找后，对话文本已设置: " .. tostring(dialogueText.text))
            -- 显示选项（如果有）
            if TableHelper.GetCount(currentOptions) > 0 then
                DialogueUI.ShowOptions()
            end
        end
    end
    
end

-- 关闭对话
function DialogueUI.CloseDialogue()
    -- 如果正在打字，直接显示全部文本
    if isTyping then
        DialogueUI.SkipTyping()
        return
    end
    
    -- 清除选项UI和数据
    ClearOptions()
    ClearOptionsData()
    
    -- 调用回调
    if onDialogueClosed then
        onDialogueClosed()
        onDialogueClosed = nil
    end
    
    -- 清除选项回调
    onOptionSelected = nil
    
    -- 隐藏UI
    if currentUI then
        UIHelper.HideLuaUI("DialogueUI")
    end
end

-- 检查是否可以关闭
function DialogueUI.CanClose()
    return not isTyping
end

-- Unity生命周期：初始化
function DialogueUI.OnInitialize(ui)
    print("[DialogueUI.lua] OnInitialize被调用")
    currentUI = ui
    
    -- 打印UI层级结构（用于调试）
    print("[DialogueUI] UI层级结构:")
    PrintUITree(ui.transform)
    
    -- 初始化组件引用
    InitializeComponents(ui)
    
    -- 绑定关闭按钮
    if closeButton then
        UIHelper.BindButtonWithSound(closeButton, DialogueUI.CloseDialogue)
    end
    
    -- 默认隐藏面板
    if dialoguePanel then
        dialoguePanel.gameObject:SetActive(false)
    end
end

-- Unity生命周期：显示
function DialogueUI.OnShow(ui)
    -- 触发对话开始事件，禁用玩家操作
    EventHelper.Trigger("DIALOGUE_START")
    print("[DialogueUI] 对话已显示，玩家操作已禁用")
end

-- Unity生命周期：隐藏
function DialogueUI.OnHide(ui)
    print("[DialogueUI.lua] OnHide被调用")
    
    -- 停止打字机效果
    if typingCoroutine then
        CoroutineHelper.Stop(typingCoroutine)
        typingCoroutine = nil
    end
    isTyping = false
    
    -- 触发对话结束事件，恢复玩家操作
    EventHelper.Trigger("DIALOGUE_END")
    print("[DialogueUI] 对话已隐藏，玩家操作已恢复")
end

-- Unity生命周期：销毁
function DialogueUI.OnDestroy(ui)
    print("[DialogueUI.lua] OnDestroy被调用")
    
    -- 清理
    if typingCoroutine then
        CoroutineHelper.Stop(typingCoroutine)
        typingCoroutine = nil
    end
    
    ClearOptions()
    ClearOptionsData()
    
    currentUI = nil
    npcNameText = nil
    dialogueText = nil
    npcAvatarImage = nil
    closeButton = nil
    optionsContainer = nil
    OptionButtonTemplate = nil
    onDialogueClosed = nil
    onOptionSelected = nil
end

-- Unity生命周期：Update（检测输入）
function DialogueUI.Update(ui)
    if not currentUI or not currentUI.gameObject.activeSelf then
        return
    end
    
    -- 检测ESC键关闭对话
    if CS.UnityEngine.Input.GetKeyDown(CS.UnityEngine.KeyCode.Escape) then
        DialogueUI.CloseDialogue()
        return
    end
    
    -- 检测鼠标左键或空格键（跳过打字机效果或继续对话）
    if CS.UnityEngine.Input.GetMouseButtonDown(0) or CS.UnityEngine.Input.GetKeyDown(CS.UnityEngine.KeyCode.Space) then
        -- 如果点击在UI上，不处理（让UI按钮正常响应）
        if IsPointerOverUI() then
            return
        end
        
        -- 如果正在打字，跳过打字机效果
        if isTyping then
            DialogueUI.SkipTyping()
            return
        end
        
        -- 如果有选项正在显示，不关闭对话（让玩家选择选项）
        if TableHelper.GetCount(currentOptions) > 0 then
            return
        end
        
        -- 如果没有选项且不在打字，关闭对话
        if DialogueUI.CanClose() then
            DialogueUI.CloseDialogue()
        end
    end
end

return DialogueUI

